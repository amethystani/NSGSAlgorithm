<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Pipeline Visualization</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            background-color: #1e1e2f;
            color: #e0e0e0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            padding: 20px 0;
            text-align: center;
            margin-bottom: 40px;
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
            background: linear-gradient(90deg, #ff4b1f, #ff9068);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        h2 {
            font-size: 1.8rem;
            color: #ff9068;
            margin-top: 40px;
        }
        
        .pipeline-container {
            position: relative;
            height: 600px;
            background-color: #2d2d44;
            border-radius: 12px;
            overflow: hidden;
            margin-top: 30px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }
        
        .controls {
            display: flex;
            justify-content: space-between;
            margin: 20px 0;
        }
        
        .control-button {
            background: linear-gradient(135deg, #ff4b1f, #ff9068);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .control-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        .control-button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .pipeline-type {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        .type-button {
            background-color: #2d2d44;
            color: #e0e0e0;
            border: 1px solid #ff9068;
            padding: 8px 16px;
            margin: 0 10px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .type-button.active {
            background: linear-gradient(135deg, #ff4b1f, #ff9068);
            color: white;
        }
        
        /* Animation elements */
        .cpu, .gpu, .memory {
            position: absolute;
            border-radius: 10px;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.5s ease;
        }
        
        .cpu {
            background-color: #3498db;
            width: 120px;
            height: 80px;
        }
        
        .gpu {
            background-color: #e74c3c;
            width: 120px;
            height: 80px;
        }
        
        .memory {
            background-color: #2ecc71;
            width: 120px;
            height: 60px;
        }
        
        .data-packet {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(45deg, #fff, #ddd);
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            z-index: 10;
            transition: all 0.5s linear;
        }
        
        .arrow {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, rgba(255,255,255,0.2), rgba(255,255,255,0.8));
            z-index: 5;
        }
        
        .arrow:after {
            content: '';
            position: absolute;
            right: 0;
            top: -6px;
            border: 8px solid transparent;
            border-left: 12px solid rgba(255,255,255,0.8);
        }
        
        .explanation {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            text-align: center;
            padding: 15px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 8px;
            margin: 0 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .explanation.visible {
            opacity: 1;
        }
        
        .code-display {
            position: absolute;
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-width: 400px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        .highlight {
            color: #61afef;
            font-weight: bold;
        }
        
        .legend {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 15px;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>GPU-Accelerated Pre/Post-Processing Hybrid Pipeline</h1>
        </div>
    </header>
    
    <div class="container">
        <p>This interactive visualization demonstrates how the GPU-accelerated hybrid pipeline works, showing the flow of data and processing steps in real-time.</p>
        
        <div class="pipeline-type">
            <button class="type-button active" id="traditional-btn">Traditional Pipeline</button>
            <button class="type-button" id="hybrid-btn">Hybrid GPU Pipeline</button>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: #3498db;"></div>
                <span>CPU Processing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #e74c3c;"></div>
                <span>GPU Processing</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #2ecc71;"></div>
                <span>Memory</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(45deg, #fff, #ddd);"></div>
                <span>Data Packets</span>
            </div>
        </div>
        
        <div class="pipeline-container" id="pipeline-container">
            <!-- Components will be added here by JavaScript -->
        </div>
        
        <div class="controls">
            <button id="start-btn" class="control-button">Start Animation</button>
            <button id="reset-btn" class="control-button" disabled>Reset</button>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const pipelineContainer = document.getElementById('pipeline-container');
            const startBtn = document.getElementById('start-btn');
            const resetBtn = document.getElementById('reset-btn');
            const traditionalBtn = document.getElementById('traditional-btn');
            const hybridBtn = document.getElementById('hybrid-btn');
            
            let currentPipeline = 'traditional';
            let animationRunning = false;
            let timeouts = [];
            
            // Set up pipeline components
            function setupTraditionalPipeline() {
                pipelineContainer.innerHTML = '';
                
                // Create components
                const cpuMemory = createComponent('memory', 'CPU Memory', 250, 50);
                const gpuMemory = createComponent('memory', 'GPU Memory', 250, 500);
                
                const cpuPreProcess = createComponent('cpu', 'CPU Pre-processing', 100, 180);
                const gpuInference = createComponent('gpu', 'GPU Inference', 250, 300);
                const cpuPostProcess = createComponent('cpu', 'CPU Post-processing', 400, 180);
                
                const explanation = document.createElement('div');
                explanation.className = 'explanation';
                explanation.innerHTML = 'Traditional pipeline requires costly memory transfers between CPU and GPU';
                pipelineContainer.appendChild(explanation);
                
                // Create arrows
                createArrow(cpuMemory, cpuPreProcess);
                createArrow(cpuPreProcess, gpuMemory);
                createArrow(gpuMemory, gpuInference);
                createArrow(gpuInference, gpuMemory);
                createArrow(gpuMemory, cpuPostProcess);
                createArrow(cpuPostProcess, cpuMemory);
                
                // Show explanation
                setTimeout(() => {
                    explanation.classList.add('visible');
                }, 500);
                
                return {
                    cpuMemory, 
                    gpuMemory, 
                    cpuPreProcess, 
                    gpuInference, 
                    cpuPostProcess,
                    explanation
                };
            }
            
            function setupHybridPipeline() {
                pipelineContainer.innerHTML = '';
                
                // Create components
                const gpuMemory = createComponent('memory', 'Unified GPU Memory', 250, 50);
                
                const gpuPreProcess = createComponent('gpu', 'GPU Pre-processing', 100, 200);
                const gpuInference = createComponent('gpu', 'YOLOv8 Inference', 250, 300);
                const gpuPostProcess = createComponent('gpu', 'GPU Post-processing', 400, 200);
                
                // Create code display
                const codeDisplay = document.createElement('div');
                codeDisplay.className = 'code-display';
                codeDisplay.innerHTML = `
// Novel memory optimization
cl::Buffer inputBuffer(context, 
  <span class="highlight">CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR</span>, 
  imgSize, imgData);
cl::Kernel normalizeKernel(program, "normalize");
normalizeKernel.setArg(0, inputBuffer);`;
                codeDisplay.style.top = '400px';
                codeDisplay.style.left = '50px';
                pipelineContainer.appendChild(codeDisplay);
                
                const explanation = document.createElement('div');
                explanation.className = 'explanation';
                explanation.innerHTML = 'Hybrid pipeline keeps data on GPU throughout the process, eliminating costly transfers';
                pipelineContainer.appendChild(explanation);
                
                // Create arrows
                createArrow(gpuMemory, gpuPreProcess);
                createArrow(gpuPreProcess, gpuInference);
                createArrow(gpuInference, gpuPostProcess);
                createArrow(gpuPostProcess, gpuMemory);
                
                // Show explanation
                setTimeout(() => {
                    explanation.classList.add('visible');
                }, 500);
                
                return {
                    gpuMemory, 
                    gpuPreProcess, 
                    gpuInference, 
                    gpuPostProcess,
                    codeDisplay,
                    explanation
                };
            }
            
            function createComponent(type, text, x, y) {
                const component = document.createElement('div');
                component.className = type;
                component.textContent = text;
                component.style.left = `${x}px`;
                component.style.top = `${y}px`;
                pipelineContainer.appendChild(component);
                return component;
            }
            
            function createArrow(from, to) {
                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();
                
                const containerRect = pipelineContainer.getBoundingClientRect();
                
                // Calculate positions relative to the container
                const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                const fromY = fromRect.top - containerRect.top + fromRect.height / 2;
                const toX = toRect.left - containerRect.left + toRect.width / 2;
                const toY = toRect.top - containerRect.top + toRect.height / 2;
                
                // Calculate angle
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                
                // Create arrow
                const arrow = document.createElement('div');
                arrow.className = 'arrow';
                arrow.style.width = `${length}px`;
                arrow.style.left = `${fromX}px`;
                arrow.style.top = `${fromY}px`;
                arrow.style.transform = `rotate(${angle}rad)`;
                arrow.style.transformOrigin = '0 50%';
                
                pipelineContainer.appendChild(arrow);
                return arrow;
            }
            
            function createDataPacket() {
                const packet = document.createElement('div');
                packet.className = 'data-packet';
                pipelineContainer.appendChild(packet);
                return packet;
            }
            
            function moveDataPacket(packet, from, to, duration, delay = 0) {
                const fromRect = from.getBoundingClientRect();
                const toRect = to.getBoundingClientRect();
                const containerRect = pipelineContainer.getBoundingClientRect();
                
                // Calculate positions relative to the container
                const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                const fromY = fromRect.top - containerRect.top + fromRect.height / 2;
                const toX = toRect.left - containerRect.left + toRect.width / 2;
                const toY = toRect.top - containerRect.top + toRect.height / 2;
                
                packet.style.left = `${fromX - 10}px`;
                packet.style.top = `${fromY - 10}px`;
                
                const timeout = setTimeout(() => {
                    packet.style.transition = `all ${duration}ms linear`;
                    packet.style.left = `${toX - 10}px`;
                    packet.style.top = `${toY - 10}px`;
                }, delay);
                
                timeouts.push(timeout);
                
                return new Promise(resolve => {
                    const timeout = setTimeout(() => {
                        resolve();
                    }, delay + duration);
                    timeouts.push(timeout);
                });
            }
            
            // Animation sequences
            async function animateTraditionalPipeline(components) {
                animationRunning = true;
                startBtn.disabled = true;
                
                const {cpuMemory, gpuMemory, cpuPreProcess, gpuInference, cpuPostProcess} = components;
                
                // Initial data
                const packet1 = createDataPacket();
                
                // Animation steps
                await moveDataPacket(packet1, cpuMemory, cpuPreProcess, 1000);
                cpuPreProcess.style.boxShadow = '0 0 20px #3498db';
                
                await new Promise(r => {
                    const timeout = setTimeout(r, 1000);
                    timeouts.push(timeout);
                });
                cpuPreProcess.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // CPU to GPU transfer (slow)
                packet1.style.backgroundColor = '#ff9068';
                await moveDataPacket(packet1, cpuPreProcess, gpuMemory, 2000);
                
                // GPU inference
                await moveDataPacket(packet1, gpuMemory, gpuInference, 1000);
                gpuInference.style.boxShadow = '0 0 20px #e74c3c';
                
                await new Promise(r => {
                    const timeout = setTimeout(r, 1500);
                    timeouts.push(timeout);
                });
                gpuInference.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // GPU to CPU transfer (slow again)
                await moveDataPacket(packet1, gpuInference, gpuMemory, 1000);
                packet1.style.backgroundColor = '#fff';
                await moveDataPacket(packet1, gpuMemory, cpuPostProcess, 2000);
                
                // CPU post-processing
                cpuPostProcess.style.boxShadow = '0 0 20px #3498db';
                await new Promise(r => {
                    const timeout = setTimeout(r, 1000);
                    timeouts.push(timeout);
                });
                cpuPostProcess.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // Final result back to CPU memory
                await moveDataPacket(packet1, cpuPostProcess, cpuMemory, 1000);
                
                // Show bottleneck explanation
                const bottleneckExplanation = document.createElement('div');
                bottleneckExplanation.className = 'explanation';
                bottleneckExplanation.style.top = '250px';
                bottleneckExplanation.innerHTML = 'Notice the bottlenecks in data transfer between CPU and GPU memory';
                bottleneckExplanation.style.backgroundColor = 'rgba(231, 76, 60, 0.7)';
                pipelineContainer.appendChild(bottleneckExplanation);
                
                const timeout = setTimeout(() => {
                    bottleneckExplanation.classList.add('visible');
                }, 500);
                timeouts.push(timeout);
                
                resetBtn.disabled = false;
            }
            
            async function animateHybridPipeline(components) {
                animationRunning = true;
                startBtn.disabled = true;
                
                const {gpuMemory, gpuPreProcess, gpuInference, gpuPostProcess, codeDisplay} = components;
                
                // Initial data
                const packet1 = createDataPacket();
                
                // Animation steps
                await moveDataPacket(packet1, gpuMemory, gpuPreProcess, 1000);
                
                // GPU pre-processing (fast)
                gpuPreProcess.style.boxShadow = '0 0 20px #e74c3c';
                await new Promise(r => {
                    const timeout = setTimeout(r, 800);
                    timeouts.push(timeout);
                });
                gpuPreProcess.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // Show code explanation
                codeDisplay.style.opacity = 1;
                
                // Move to inference
                await moveDataPacket(packet1, gpuPreProcess, gpuInference, 800);
                
                // GPU inference
                gpuInference.style.boxShadow = '0 0 20px #e74c3c';
                await new Promise(r => {
                    const timeout = setTimeout(r, 1200);
                    timeouts.push(timeout);
                });
                gpuInference.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // Move to post-processing (still on GPU)
                await moveDataPacket(packet1, gpuInference, gpuPostProcess, 800);
                
                // GPU post-processing
                gpuPostProcess.style.boxShadow = '0 0 20px #e74c3c';
                await new Promise(r => {
                    const timeout = setTimeout(r, 800);
                    timeouts.push(timeout);
                });
                gpuPostProcess.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
                
                // Final result
                await moveDataPacket(packet1, gpuPostProcess, gpuMemory, 800);
                
                // Show advantage explanation
                const advantageExplanation = document.createElement('div');
                advantageExplanation.className = 'explanation';
                advantageExplanation.style.top = '400px';
                advantageExplanation.innerHTML = 'Zero-copy operations eliminate memory transfers, greatly improving performance for large segmentation masks';
                advantageExplanation.style.backgroundColor = 'rgba(46, 204, 113, 0.7)';
                pipelineContainer.appendChild(advantageExplanation);
                
                const timeout = setTimeout(() => {
                    advantageExplanation.classList.add('visible');
                }, 500);
                timeouts.push(timeout);
                
                resetBtn.disabled = false;
            }
            
            // Event listeners
            startBtn.addEventListener('click', function() {
                if (currentPipeline === 'traditional') {
                    const components = setupTraditionalPipeline();
                    animateTraditionalPipeline(components);
                } else {
                    const components = setupHybridPipeline();
                    animateHybridPipeline(components);
                }
            });
            
            resetBtn.addEventListener('click', function() {
                // Clear all timeouts
                timeouts.forEach(clearTimeout);
                timeouts = [];
                
                // Reset the animation
                if (currentPipeline === 'traditional') {
                    setupTraditionalPipeline();
                } else {
                    setupHybridPipeline();
                }
                
                startBtn.disabled = false;
                resetBtn.disabled = true;
                animationRunning = false;
            });
            
            traditionalBtn.addEventListener('click', function() {
                if (!animationRunning && currentPipeline !== 'traditional') {
                    currentPipeline = 'traditional';
                    traditionalBtn.classList.add('active');
                    hybridBtn.classList.remove('active');
                    setupTraditionalPipeline();
                    startBtn.disabled = false;
                    resetBtn.disabled = true;
                }
            });
            
            hybridBtn.addEventListener('click', function() {
                if (!animationRunning && currentPipeline !== 'hybrid') {
                    currentPipeline = 'hybrid';
                    hybridBtn.classList.add('active');
                    traditionalBtn.classList.remove('active');
                    setupHybridPipeline();
                    startBtn.disabled = false;
                    resetBtn.disabled = true;
                }
            });
            
            // Initial setup
            setupTraditionalPipeline();
        });
    </script>
</body>
</html>